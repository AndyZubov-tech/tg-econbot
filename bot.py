# -*- coding: utf-8 -*-
"""bot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r1dMuOgxdJPkKYMUfds578qEvTFfch6U
"""

import asyncio
import logging
import json
import sqlite3
import pandas as pd
import nest_asyncio
import re
import os # <-- –î–û–ë–ê–í–ò–¢–¨ –≠–¢–£ –°–¢–†–û–ö–£

from aiogram import Bot, Dispatcher, types
from aiogram.filters import CommandStart, Command
from aiogram.types import CallbackQuery, FSInputFile
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.exceptions import TelegramBadRequest
# –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º FSM –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è–º–∏
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage


# --- –ù–ê–°–¢–†–û–ô–ö–ò –ò –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ---

nest_asyncio.apply()
logging.basicConfig(level=logging.INFO)

# –ò–ó–ú–ï–ù–ï–ù–û: –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è
API_TOKEN = os.getenv('TELEGRAM_API_TOKEN')

ADMIN_IDS = [830902845]

# –ò–ó–ú–ï–ù–ï–ù–û: –£–∫–∞–∑—ã–≤–∞–µ–º –ø—É—Ç—å –∫ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–º—É —Ö—Ä–∞–Ω–∏–ª–∏—â—É Amvera
DB_FILE = '/data/quiz_database.db'

class QuizState(StatesGroup):
    answering = State()

# --- –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ---

def clean_html(raw_html: str) -> str:
    if not raw_html:
        return ""
    clean_text = raw_html.replace('<p>', '').replace('</p>', '\n')
    clean_text = clean_text.replace('<b>', '').replace('</b>', '')
    clean_text = clean_text.replace('<i>', '').replace('</i>', '')
    clean_text = clean_text.replace('<code>', '').replace('</code>', '')
    return clean_text.strip()

def format_user_answer(text: str) -> str:
    return "".join(sorted(re.sub(r'[\s,.]', '', text).lower()))

# --- –†–ê–ë–û–¢–ê –° –ë–î ---
def init_db():
    with sqlite3.connect(DB_FILE) as conn:
        cur = conn.cursor()
        cur.execute('''CREATE TABLE IF NOT EXISTS users (user_id INTEGER PRIMARY KEY, username TEXT, first_name TEXT)''')
        cur.execute('''CREATE TABLE IF NOT EXISTS user_answers (id INTEGER PRIMARY KEY AUTOINCREMENT, user_id INTEGER, question_id INTEGER, is_correct INTEGER, topic TEXT)''')
        cur.execute('''
            CREATE TABLE IF NOT EXISTS tasks (
                id INTEGER PRIMARY KEY, topic TEXT NOT NULL, sub_topic TEXT,
                question_type TEXT NOT NULL, author TEXT, source TEXT,
                question_text TEXT NOT NULL, options_json TEXT NOT NULL,
                correct_answer TEXT NOT NULL, explanation TEXT
            )''')
        conn.commit()

def add_user(user_id, username, first_name):
    with sqlite3.connect(DB_FILE) as conn:
        cur = conn.cursor()
        cur.execute("INSERT OR IGNORE INTO users (user_id, username, first_name) VALUES (?, ?, ?)", (user_id, username, first_name))
        conn.commit()

def log_answer(user_id, question_id, is_correct, topic):
    with sqlite3.connect(DB_FILE) as conn:
        cur = conn.cursor()
        cur.execute("INSERT INTO user_answers (user_id, question_id, is_correct, topic) VALUES (?, ?, ?, ?)", (user_id, question_id, is_correct, topic))
        conn.commit()

def get_available_topics():
    with sqlite3.connect(DB_FILE) as conn:
        cur = conn.cursor()
        cur.execute("SELECT DISTINCT topic FROM tasks ORDER BY topic")
        topics = [row[0] for row in cur.fetchall()]
    return topics

# --- –ê–î–ú–ò–ù-–ü–ê–ù–ï–õ–¨: –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Å–±–æ—Ä–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ---
def get_summary_stats():
    """–°–æ–±–∏—Ä–∞–µ—Ç –∫—Ä–∞—Ç–∫—É—é —Å–≤–æ–¥–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º."""
    with sqlite3.connect(DB_FILE) as conn:
        cur = conn.cursor()
        # –û–±—â–µ–µ —á–∏—Å–ª–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        cur.execute("SELECT COUNT(*) FROM users")
        total_users = cur.fetchone()[0]

        # –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –æ—Ç–≤–µ—Ç–∞–º
        cur.execute("SELECT COUNT(*), SUM(is_correct) FROM user_answers")
        total_answers, total_correct = cur.fetchone()
        accuracy = (total_correct / total_answers) * 100 if total_answers and total_correct else 0

        # –¢–æ–ø-3 —Å–∞–º—ã—Ö —Å–ª–æ–∂–Ω—ã—Ö —Ç–µ–º
        cur.execute("SELECT topic, SUM(1 - is_correct) as errors FROM user_answers GROUP BY topic ORDER BY errors DESC LIMIT 3")
        worst_topics = cur.fetchall()

    return {"total_users": total_users, "total_answers": total_answers, "accuracy": accuracy, "worst_topics": worst_topics}

def create_excel_report():
    """–°–æ–∑–¥–∞–µ—Ç –¥–µ—Ç–∞–ª—å–Ω—ã–π Excel-–æ—Ç—á–µ—Ç –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É."""
    with sqlite3.connect(DB_FILE) as conn:
        # –ó–∞–ø—Ä–æ—Å –¥–ª—è —Å–≤–æ–¥–∫–∏ –ø–æ –∫–∞–∂–¥–æ–º—É —É—á–µ–Ω–∏–∫—É
        query_summary = """
            SELECT
                u.user_id, u.first_name, u.username,
                COUNT(ua.id) as total_answers,
                SUM(ua.is_correct) as correct_answers,
                (CAST(SUM(ua.is_correct) AS REAL) / COUNT(ua.id)) * 100 as accuracy
            FROM users u
            LEFT JOIN user_answers ua ON u.user_id = ua.user_id
            GROUP BY u.user_id ORDER BY accuracy DESC
        """
        df_summary = pd.read_sql_query(query_summary, conn)

        # –ó–∞–ø—Ä–æ—Å –¥–ª—è –≤—ã–≥—Ä—É–∑–∫–∏ –≤—Å–µ—Ö –æ—Ç–≤–µ—Ç–æ–≤
        query_all_answers = """
            SELECT ua.id, ua.user_id, u.first_name, ua.question_id, ua.topic, ua.is_correct
            FROM user_answers ua
            JOIN users u ON ua.user_id = u.user_id
            ORDER BY ua.id
        """
        df_all_answers = pd.read_sql_query(query_all_answers, conn)

    # –°–æ–∑–¥–∞–Ω–∏–µ Excel —Ñ–∞–π–ª–∞ —Å –¥–≤—É–º—è –ª–∏—Å—Ç–∞–º–∏
    file_path = "student_stats_report.xlsx"
    with pd.ExcelWriter(file_path) as writer:
        df_summary.to_excel(writer, sheet_name='–°–≤–æ–¥–∫–∞ –ø–æ —É—á–µ–Ω–∏–∫–∞–º', index=False)
        df_all_answers.to_excel(writer, sheet_name='–í—Å–µ –æ—Ç–≤–µ—Ç—ã', index=False)

    return file_path



# --- –ë–õ–û–ö –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–• –§–£–ù–ö–¶–ò–ô –ë–û–¢–ê ---

async def send_question(message: types.Message, state: FSMContext, topic: str = None):
    with sqlite3.connect(DB_FILE) as conn:
        cur = conn.cursor()
        query = "SELECT id, topic, question_text, options_json, correct_answer, explanation, question_type FROM tasks "
        if topic and topic != "random":
            cur.execute(query + "WHERE topic = ? ORDER BY RANDOM() LIMIT 1", (topic,))
        else:
            cur.execute(query + "ORDER BY RANDOM() LIMIT 1")
        question_row = cur.fetchone()

    if not question_row:
        await message.answer("–í —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ–∫–∞ –Ω–µ—Ç –≤–æ–ø—Ä–æ—Å–æ–≤.")
        await state.clear()
        return

    q_id, q_topic, q_text, q_options_json, q_correct, q_explanation, q_type = question_row

    cleaned_question_text = clean_html(q_text)
    question_text_formatted = f"<b>–¢–µ–º–∞: {q_topic}</b>\n\n<b>–í–æ–ø—Ä–æ—Å {q_id}:</b>\n{cleaned_question_text}\n\n"

    options = json.loads(q_options_json)
    if options:
        for key, value in options.items():
            cleaned_option_text = clean_html(value)
            question_text_formatted += f"<b>{key.upper()}.</b> {cleaned_option_text}\n"

    if q_type in ["–í–µ—Ä–Ω–æ/–ù–µ–≤–µ—Ä–Ω–æ", "–û–¥–∏–Ω –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç"]:
         question_text_formatted += "\n‚û°Ô∏è <i>–û—Ç–ø—Ä–∞–≤—å—Ç–µ –±—É–∫–≤—É –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞.</i>"
    elif q_type == "–í—Å–µ –≤–µ—Ä–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã":
         question_text_formatted += "\n‚û°Ô∏è <i>–û—Ç–ø—Ä–∞–≤—å—Ç–µ –±—É–∫–≤—ã –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤ —Å–ª–∏—Ç–Ω–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∞–±–≤).</i>"
    else: # –û—Ç–∫—Ä—ã—Ç—ã–π –æ—Ç–≤–µ—Ç
         question_text_formatted += "\n‚û°Ô∏è <i>–û—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∞—à –æ—Ç–≤–µ—Ç –≤ –≤–∏–¥–µ —Ç–µ–∫—Å—Ç–∞ –∏–ª–∏ —á–∏—Å–ª–∞.</i>"

    await message.answer(question_text_formatted, parse_mode="HTML")

    await state.update_data(
        question_id=q_id,
        correct_answer=q_correct,
        topic=q_topic,
        explanation=q_explanation
    )
    await state.set_state(QuizState.answering)


# --- –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò ---

@dp.message(CommandStart())
async def send_welcome(message: types.Message, state: FSMContext):
    await state.clear()
    add_user(message.from_user.id, message.from_user.username, message.from_user.first_name)
    await message.reply("–ü—Ä–∏–≤–µ—Ç! –Ø —Ç–≤–æ–π –ø–æ–º–æ—â–Ω–∏–∫ –¥–ª—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –∫ –æ–ª–∏–º–ø–∏–∞–¥–∞–º. üèÜ\n–ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Ç–µ—Å—Ç, –∏—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É /test")

@dp.message(Command("test"))
async def show_topics_menu(message: types.Message, state: FSMContext):
    await state.clear()
    builder = InlineKeyboardBuilder()
    available_topics = get_available_topics()
    for index, topic in enumerate(available_topics):
        builder.button(text=topic, callback_data=f"topic_idx:{index}")
    builder.button(text="üé≤ –°–ª—É—á–∞–π–Ω—ã–π —Ç–µ—Å—Ç", callback_data="topic_idx:random")
    builder.adjust(1)
    await message.answer("–í—ã–±–µ—Ä–∏ —Ç–µ–º—É –¥–ª—è —Ç–µ—Å—Ç–∞:", reply_markup=builder.as_markup())

# ... (–∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å –∏ /stats –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
# --- –û–ë–†–ê–ë–û–¢–ß–ò–ö –°–¢–ê–¢–ò–°–¢–ò–ö–ò –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø ---

@dp.message(Command("stats"))
async def show_stats(message: types.Message):
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –ª–∏—á–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
    with sqlite3.connect(DB_FILE) as conn:
        cur = conn.cursor()
        cur.execute("SELECT COUNT(*), SUM(is_correct) FROM user_answers WHERE user_id = ?", (message.from_user.id,))
        total_answered, total_correct = cur.fetchone()

    if not total_answered:
        return await message.answer("–¢—ã –µ—â–µ –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª –Ω–∏ –Ω–∞ –æ–¥–∏–Ω –≤–æ–ø—Ä–æ—Å. –ù–∞—á–Ω–∏ —Å –∫–æ–º–∞–Ω–¥—ã /test")

    accuracy = (total_correct / total_answered) * 100 if total_correct else 0

    with sqlite3.connect(DB_FILE) as conn:
        cur = conn.cursor()
        cur.execute("SELECT topic, SUM(1 - is_correct) as errors FROM user_answers WHERE user_id = ? GROUP BY topic ORDER BY errors DESC LIMIT 1", (message.from_user.id,))
        worst_topic_row = cur.fetchone()

    worst_topic = worst_topic_row[0] if worst_topic_row else "–ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞"

    stats_text = (
        f"üìä <b>–¢–≤–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n\n"
        f"–í—Å–µ–≥–æ –æ—Ç–≤–µ—á–µ–Ω–æ –≤–æ–ø—Ä–æ—Å–æ–≤: {total_answered}\n"
        f"–ü—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤: {total_correct}\n"
        f"–¢–æ—á–Ω–æ—Å—Ç—å: {accuracy:.2f}%\n\n"
        f"–¢–µ–º–∞ —Å –Ω–∞–∏–±–æ–ª—å—à–∏–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –æ—à–∏–±–æ–∫: <b>{worst_topic}</b>\n\n–ü—Ä–æ–¥–æ–ª–∂–∞–π –≤ —Ç–æ–º –∂–µ –¥—É—Ö–µ!"
    )
    await message.answer(stats_text, parse_mode="HTML")


# --- –ê–î–ú–ò–ù-–ü–ê–ù–ï–õ–¨ ---

@dp.message(Command("admin"))
async def show_admin_panel(message: types.Message):
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å, –µ—Å–ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø."""
    if message.from_user.id not in ADMIN_IDS:
        return await message.answer("–£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–µ.")

    builder = InlineKeyboardBuilder()
    builder.button(text="üìä –ö—Ä–∞—Ç–∫–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="admin:summary")
    builder.button(text="üìÑ –ü–æ–¥—Ä–æ–±–Ω—ã–π –æ—Ç—á–µ—Ç (Excel)", callback_data="admin:excel")
    builder.adjust(1)
    await message.answer("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ø–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞!", reply_markup=builder.as_markup())


@dp.callback_query(lambda c: c.data.startswith('admin:'))
async def process_admin_commands(callback_query: CallbackQuery):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ –∫–Ω–æ–ø–∫–∏ –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏."""
    if callback_query.from_user.id not in ADMIN_IDS:
        return await bot.answer_callback_query(callback_query.id, "–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω", show_alert=True)

    command = callback_query.data.split(':')[1]

    if command == 'summary':
        stats = get_summary_stats()
        worst_topics_text = "\n".join([f"  - {topic} ({errors} –æ—à–∏–±–æ–∫)" for topic, errors in stats['worst_topics']]) if stats['worst_topics'] else "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö"
        summary_text = (
            f"üìà <b>–ö—Ä–∞—Ç–∫–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –≤—Å–µ–º —É—á–µ–Ω–∏–∫–∞–º:</b>\n\n"
            f"üë§ –í—Å–µ–≥–æ —É—á–µ–Ω–∏–∫–æ–≤: <b>{stats['total_users']}</b>\n"
            f"üìù –í—Å–µ–≥–æ –æ—Ç–≤–µ—Ç–æ–≤: <b>{stats['total_answers']}</b>\n"
            f"üéØ –°—Ä–µ–¥–Ω—è—è —Ç–æ—á–Ω–æ—Å—Ç—å: <b>{stats['accuracy']:.2f}%</b>\n\n"
            f"·É£·É†·Éó –°–∞–º—ã–µ —Å–ª–æ–∂–Ω—ã–µ —Ç–µ–º—ã:\n{worst_topics_text}"
        )
        await callback_query.message.answer(summary_text, parse_mode="HTML")

    elif command == 'excel':
        await callback_query.message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ, –≥–µ–Ω–µ—Ä–∏—Ä—É—é –æ—Ç—á–µ—Ç...")
        report_path = create_excel_report()
        document = FSInputFile(report_path)
        await bot.send_document(callback_query.from_user.id, document, caption="–ü–æ–¥—Ä–æ–±–Ω—ã–π –æ—Ç—á–µ—Ç –ø–æ —É—Å–ø–µ–≤–∞–µ–º–æ—Å—Ç–∏ —É—á–µ–Ω–∏–∫–æ–≤.")

    await bot.answer_callback_query(callback_query.id)

@dp.message(QuizState.answering)
async def process_text_answer(message: types.Message, state: FSMContext):
    user_data = await state.get_data()
    question_id = user_data.get('question_id')
    correct_answer = user_data.get('correct_answer')
    topic = user_data.get('topic')
    explanation = user_data.get('explanation')

    await state.clear() # –°—Ä–∞–∑—É —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏

    user_answer_formatted = format_user_answer(message.text)
    correct_answer_formatted = format_user_answer(correct_answer)

    is_correct = 1 if user_answer_formatted == correct_answer_formatted else 0
    log_answer(message.from_user.id, question_id, is_correct, topic)

    if is_correct:
        await message.answer("‚úÖ –ê–±—Å–æ–ª—é—Ç–Ω–æ –≤–µ—Ä–Ω–æ!")
    else:
        cleaned_explanation = clean_html(explanation)
        explanation_text = cleaned_explanation if cleaned_explanation else '–û–±—ä—è—Å–Ω–µ–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.'
        response_text = f"‚ùå –ù–µ–≤–µ—Ä–Ω–æ.\n–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: <b>{correct_answer.upper()}</b>\n\n<b>–û–±—ä—è—Å–Ω–µ–Ω–∏–µ:</b> {explanation_text}"
        await message.answer(response_text, parse_mode="HTML")

    # –ò–ó–ú–ï–ù–ï–ù–û: –ù–∞—Ö–æ–¥–∏–º –∏–Ω–¥–µ–∫—Å —Ç–µ–∫—É—â–µ–π —Ç–µ–º—ã, —á—Ç–æ–±—ã –ø–µ—Ä–µ–¥–∞—Ç—å –µ–≥–æ –≤ –∫–Ω–æ–ø–∫—É "–°–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å"
    all_topics = get_available_topics()
    try:
        topic_to_continue_index = all_topics.index(topic)
    except ValueError:
        # –ï—Å–ª–∏ –ø–æ –∫–∞–∫–æ–π-—Ç–æ –ø—Ä–∏—á–∏–Ω–µ —Ç–µ–º—ã –Ω–µ—Ç –≤ —Å–ø–∏—Å–∫–µ, –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–π –≤–æ–ø—Ä–æ—Å
        topic_to_continue_index = "random"

    builder = InlineKeyboardBuilder()
    builder.button(text="‚û°Ô∏è –°–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å", callback_data=f"topic_idx:{topic_to_continue_index}")
    builder.button(text="üìã –í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥—É—é —Ç–µ–º—É", callback_data="show_topics_menu")
    await message.answer("–ì–æ—Ç–æ–≤ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å?", reply_markup=builder.as_markup())


@dp.callback_query(lambda c: c.data.startswith('topic_idx:'))
async def process_topic_selection(callback_query: CallbackQuery, state: FSMContext):
    topic_param = callback_query.data.split(':')[1]

    # –ó–∞—â–∏—Ç–∞ –æ—Ç —Å–ª—É—á–∞–π–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π, –∫–æ–≥–¥–∞ –±–æ—Ç –Ω–µ –∂–¥–µ—Ç –æ—Ç–≤–µ—Ç–∞
    if await state.get_state() is not None:
        await state.clear()

    await bot.edit_message_reply_markup(chat_id=callback_query.message.chat.id, message_id=callback_query.message.message_id, reply_markup=None)

    if topic_param == "random":
        topic_name = "random"
    else:
        try:
            topic_index = int(topic_param)
            available_topics = get_available_topics()
            if 0 <= topic_index < len(available_topics):
                topic_name = available_topics[topic_index]
            else:
                return await callback_query.message.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π –∏–Ω–¥–µ–∫—Å —Ç–µ–º—ã.")
        except (ValueError, IndexError):
            return await callback_query.message.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç callback_data.")

    await send_question(callback_query.message, state, topic_name)
    await bot.answer_callback_query(callback_query.id)

@dp.callback_query(lambda c: c.data == 'show_topics_menu')
async def process_show_topics(callback_query: CallbackQuery, state: FSMContext):
     await bot.edit_message_reply_markup(chat_id=callback_query.message.chat.id, message_id=callback_query.message.message_id, reply_markup=None)
     await show_topics_menu(callback_query.message, state)
     await bot.answer_callback_query(callback_query.id)

# --- –¢–û–ß–ö–ê –í–•–û–î–ê –ò –ó–ê–ü–£–°–ö –ë–û–¢–ê ---

async def main():
    init_db()
    print("–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞.")
    print("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!")
    await dp.start_polling(bot)

if __name__ == '__main__':
    if API_TOKEN == 'YOUR_API_TOKEN_HERE':
        print("–û—à–∏–±–∫–∞: –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—Å—Ç–∞–≤—å—Ç–µ –≤–∞—à API —Ç–æ–∫–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é API_TOKEN.")
    else:
        asyncio.run(main())

